<?php

namespace Moonwalker\Core;

use League\Route\ContainerAwareInterface;
use League\Route\ContainerAwareTrait;
use Maghead\Runtime\Collection;
use Moonwalker\Core\Errors\ValidationFailedException;
use Valitron\Validator;

class Controller implements ContainerAwareInterface
{
    use ContainerAwareTrait;

    /** @var \League\Container\Container $container */
    protected $container;

    /** @var \Valitron\Validator $validator */
    protected $validator;

    public function __construct()
    {

    }

    private function initValidator (Array $data, Array $rules = null)
    {
        if (is_null($this->validator))
            $this->validator = new Validator($data);
        else
            $this->validator->withData($data);

        if ( is_array($rules) && count($rules) >= 1)
            $this->validator->rules($rules);

        return $this->validator;
    }

    public function validate (Array $data, Array $rules)
    {
        $this->initValidator($data, $rules);
        return $this->validator->validate();
    }

    /*
     * @param Array $param This is the full set of request parameters, get it like $request->getQueryParams() in Controller context
     * @param Collection $collection This is the collection object of the model generated by Maghead
     * @param Array $metadata This provides a map of what the default pagination parameters are to be called, by default they are "page" (as in page number) and "page_size" (records par page)
     * @return mixed Returns either an array if pagination is applied, or false if not.
     */
    public function paginate (Array $params, Collection $collection, Array $metadata = null)
    {
        if (is_null($metadata))
        {
            $metadata = [
                'page' => 'page',
                'page_size' => 'page_size'
            ];
        }

        if (array_key_exists($metadata['page'], $params) && array_key_exists($metadata['page_size'], $params))
        {
            if (! $this->validate($params, [
                'integer' => [
                    [ $metadata['page'] ],
                    [ $metadata['page_size'] ]
                ]
            ]))
                throw new ValidationFailedException($this->validator->errors());
            $count = $collection->count();

            $collection->page($params['page'], $params['page_size']);
            return [
                'paging_applied' => true,
                'record_count' => $count
            ];
        }
        else
            return false;
    }

    /*
     * Constructs a new key-value array with ONLY those fields that have been run through the validator
     * i.e: If input has field `config` but `config` has not been validated, it will be stripped from the final array.
     * It also strips NULL values, workaround for: https://github.com/vlucas/valitron/issues/209#issuecomment-327541745
     * @param Array $data Original data array gotten from $request->getParsedBody()
     * @param Array $validationRules Array based rule definition for Valitron/validator. Example:
     * [
            'required' => [
                ['first_name'], ['last_name'], ['email'], ['password']
            ],
            'email' => 'email',
            'optional' => [
                ['phone'], ['timezone'], ['language']
            ],
            'lengthBetween' => [
                ['password', 5, 72]
            ],
            'slug' => [
                ['phone'], ['timezone'], ['language']
            ],
        ];
     * @returns Array
     */
    public function cherryPick (Array $data, Array $validationRules, $stripNulls = true)
    {
        $validatedKeys = [];
        foreach ($validationRules as $rule => $targets)
        {
            if (is_string($targets))
                $validatedKeys[] = $targets; // Rule that only affects one field, and thus is represented as a simple string
            elseif (is_array($targets))
            {
                foreach ($targets as $target)
                    $validatedKeys[] = $target[0]; // Because the first (often only) element is ALWAYS the name of the field in ruleMap notation
            }
        }
        $validatedKeys = array_unique($validatedKeys); // Remove duplicates since more than one constraint can target a field
        $newArray = [];

        foreach ($validatedKeys as $key)
        {
            if (array_key_exists($key, $data))
            {
                if ($stripNulls && $data[$key] == null)
                    continue;
                $newArray[$key] = $data[$key];
            }
        }

        return $newArray;
    }

    /*
     * Shorthand because this particular validation is SO very common
     */
    public function validateId (Array $args)
    {
        if (! $this->validate($args, [
            'integer' => 'id'
        ]))
            throw new ValidationFailedException($this->validator->errors());
    }
}